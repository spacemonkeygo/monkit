// Copyright (C) 2016 Space Monkey, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// WARNING: THE NON-M4 VERSIONS OF THIS FILE ARE GENERATED BY GO GENERATE!
//          ONLY MAKE CHANGES TO THE M4 FILE
//

// +build go1.7

package monkit

import (
	"context"
	"sync"
	"time"

	"github.com/spacemonkeygo/monotime"
)

var (
	contextCanceled         = context.Canceled
	contextDeadlineExceeded = context.DeadlineExceeded
)

// Span represents a 'span' of execution. A span is analogous to a stack frame.
// Spans are constructed as a side-effect of Tasks.
type Span struct {
	// sync/atomic things
	mtx spinLock

	// immutable things from construction
	id     int64
	start  time.Time
	f      *Func
	trace  *Trace
	parent *Span
	args   []interface{}
	context.Context

	// protected by mtx
	done        bool
	orphaned    bool
	children    spanBag
	annotations []Annotation
}

// SpanFromCtx loads the current Span from the given context. This assumes
// the context already had a Span created through a Task.
func SpanFromCtx(ctx context.Context) *Span {
	if s, ok := ctx.(*Span); ok && s != nil {
		return s
	} else if s, ok := ctx.Value(spanKey).(*Span); ok && s != nil {
		return s
	}
	return nil
}

func newSpan(ctx context.Context, f *Func, args []interface{},
	id int64, trace *Trace) (s *Span, exit func(*error)) {

	var parent *Span
	if s, ok := ctx.(*Span); ok && s != nil {
		ctx = s.Context
		if trace == nil {
			parent = s
			trace = parent.trace
		}
	} else if s, ok := ctx.Value(spanKey).(*Span); ok && s != nil {
		if trace == nil {
			parent = s
			trace = parent.trace
		}
	} else if trace == nil {
		trace = NewTrace(id)
		f.scope.r.observeTrace(trace)
	}

	observer := trace.getObserver()

	s = &Span{
		id:      id,
		start:   monotime.Now(),
		f:       f,
		trace:   trace,
		parent:  parent,
		args:    args,
		Context: ctx}

	if parent != nil {
		f.start(parent.f)
		parent.addChild(s)
	} else {
		f.start(nil)
		f.scope.r.rootSpanStart(s)
	}

	if observer != nil {
		observer.Start(s)
	}

	return s, func(errptr *error) {
		rec := recover()
		panicked := rec != nil

		finish := monotime.Now()

		var err error
		if errptr != nil {
			err = *errptr
		}
		s.f.end(err, panicked, finish.Sub(s.start))

		var children []*Span
		s.mtx.Lock()
		s.done = true
		orphaned := s.orphaned
		s.children.Iterate(func(child *Span) {
			children = append(children, child)
		})
		s.mtx.Unlock()
		for _, child := range children {
			child.orphan()
		}

		if s.parent != nil {
			s.parent.removeChild(s)
			if orphaned {
				s.f.scope.r.orphanEnd(s)
			}
		} else {
			s.f.scope.r.rootSpanEnd(s)
		}

		if observer != nil {
			observer.Finish(s, err, panicked, finish)
		}

		if panicked {
			panic(rec)
		}
	}
}

var taskSecret context.Context = &taskSecretT{}

// Tasks are created (sometimes implicitly) from Funcs. A Task should be called
// at the start of a monitored task, and its return value should be called
// at the stop of said task.
type Task func(ctx *context.Context, args ...interface{}) func(*error)

// Task returns a new Task for use, creating an associated Func if necessary.
// It also adds a new Span to the given ctx during execution. Expected usage
// like:
//
//   var mon = monkit.Package()
//
//   func MyFunc(ctx context.Context, arg1, arg2 string) (err error) {
//     defer mon.Task()(&ctx, arg1, arg2)(&err)
//     ...
//   }
//
// or
//
//   var (
//     mon = monkit.Package()
//     funcTask = mon.Task()
//   )
//
//   func MyFunc(ctx context.Context, arg1, arg2 string) (err error) {
//     defer funcTask(&ctx, arg1, arg2)(&err)
//     ...
//   }
//
// Task uses runtime.Caller to determine the associated Func name. See
// TaskNamed if you want to supply your own name. See Func.Task if you already
// have a Func.
//
// If you want to control Trace creation, see Func.ResetTrace and
// Func.RemoteTrace
func (s *Scope) Task() Task {
	var initOnce sync.Once
	var f *Func
	init := func() {
		f = s.FuncNamed(callerFunc(3))
	}
	return Task(func(ctx *context.Context,
		args ...interface{}) func(*error) {
		ctx = cleanCtx(ctx)
		if ctx == &taskSecret && taskArgs(f, args) {
			return nil
		}
		initOnce.Do(init)
		s, exit := newSpan(*ctx, f, args, NewId(), nil)
		if ctx != &unparented {
			*ctx = s
		}
		return exit
	})
}

// Task returns a new Task for use on this Func. It also adds a new Span to
// the given ctx during execution.
//
//   var mon = monkit.Package()
//
//   func MyFunc(ctx context.Context, arg1, arg2 string) (err error) {
//     f := mon.Func()
//     defer f.Task(&ctx, arg1, arg2)(&err)
//     ...
//   }
//
// It's more expected for you to use mon.Task directly. See RemoteTrace or
// ResetTrace if you want greater control over creating new traces.
func (f *Func) Task(ctx *context.Context, args ...interface{}) func(*error) {
	ctx = cleanCtx(ctx)
	if ctx == &taskSecret && taskArgs(f, args) {
		return nil
	}
	s, exit := newSpan(*ctx, f, args, NewId(), nil)
	if ctx != &unparented {
		*ctx = s
	}
	return exit
}

// RemoteTrace is like Func.Task, except you can specify the trace and span id.
// Needed for things like the Zipkin plugin.
func (f *Func) RemoteTrace(ctx *context.Context, spanId int64, trace *Trace,
	args ...interface{}) func(*error) {
	ctx = cleanCtx(ctx)
	if trace != nil {
		f.scope.r.observeTrace(trace)
	}
	s, exit := newSpan(*ctx, f, args, spanId, trace)
	if ctx != &unparented {
		*ctx = s
	}
	return exit
}

// ResetTrace is like Func.Task, except it always creates a new Trace.
func (f *Func) ResetTrace(ctx *context.Context,
	args ...interface{}) func(*error) {
	ctx = cleanCtx(ctx)
	if ctx == &taskSecret && taskArgs(f, args) {
		return nil
	}
	trace := NewTrace(NewId())
	f.scope.r.observeTrace(trace)
	s, exit := newSpan(*ctx, f, args, trace.Id(), trace)
	if ctx != &unparented {
		*ctx = s
	}
	return exit
}

var unparented = context.Background()

func cleanCtx(ctx *context.Context) *context.Context {
	if ctx == nil {
		return &unparented
	}
	if *ctx == nil {
		*ctx = context.Background()
		// possible upshot of what we just did:
		//
		//   func MyFunc(ctx context.Context) {
		//     // ctx == nil here
		//     defer mon.Task()(&ctx)(nil)
		//     // ctx != nil here
		//   }
		//
		//   func main() { MyFunc(nil) }
		//
	}
	return ctx
}
